{"mappings":"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","sources":["node_modules/idb-keyval/dist/compat.js","node_modules/safari-14-idb-fix/dist/index.js","src/service-workers.js"],"sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport safariFix from 'safari-14-idb-fix';\n\nfunction promisifyRequest(request) {\n  return new Promise(function (resolve, reject) {\n    // @ts-ignore - file size hacks\n    request.oncomplete = request.onsuccess = function () {\n      return resolve(request.result);\n    }; // @ts-ignore - file size hacks\n\n\n    request.onabort = request.onerror = function () {\n      return reject(request.error);\n    };\n  });\n}\n\nfunction createStore(dbName, storeName) {\n  var dbp = safariFix().then(function () {\n    var request = indexedDB.open(dbName);\n\n    request.onupgradeneeded = function () {\n      return request.result.createObjectStore(storeName);\n    };\n\n    return promisifyRequest(request);\n  });\n  return function (txMode, callback) {\n    return dbp.then(function (db) {\n      return callback(db.transaction(storeName, txMode).objectStore(storeName));\n    });\n  };\n}\n\nvar defaultGetStoreFunc;\n\nfunction defaultGetStore() {\n  if (!defaultGetStoreFunc) {\n    defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n  }\n\n  return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction get(key) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    return promisifyRequest(store.get(key));\n  });\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction set(key, value) {\n  var customStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.put(value, key);\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction setMany(entries) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    entries.forEach(function (entry) {\n      return store.put(entry[1], entry[0]);\n    });\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction getMany(keys) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    return Promise.all(keys.map(function (key) {\n      return promisifyRequest(store.get(key));\n    }));\n  });\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction update(key, updater) {\n  var customStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    return (// Need to create the promise manually.\n      // If I try to chain promises, the transaction closes in browsers\n      // that use a promise polyfill (IE10/11).\n      new Promise(function (resolve, reject) {\n        store.get(key).onsuccess = function () {\n          try {\n            store.put(updater(this.result), key);\n            resolve(promisifyRequest(store.transaction));\n          } catch (err) {\n            reject(err);\n          }\n        };\n      })\n    );\n  });\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction del(key) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.delete(key);\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction delMany(keys) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    keys.forEach(function (key) {\n      return store.delete(key);\n    });\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction clear() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.clear();\n    return promisifyRequest(store.transaction);\n  });\n}\n\nfunction eachCursor(store, callback) {\n  store.openCursor().onsuccess = function () {\n    if (!this.result) return;\n    callback(this.result);\n    this.result.continue();\n  };\n\n  return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction keys() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    // Fast path for modern browsers\n    if (store.getAllKeys) {\n      return promisifyRequest(store.getAllKeys());\n    }\n\n    var items = [];\n    return eachCursor(store, function (cursor) {\n      return items.push(cursor.key);\n    }).then(function () {\n      return items;\n    });\n  });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction values() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    // Fast path for modern browsers\n    if (store.getAll) {\n      return promisifyRequest(store.getAll());\n    }\n\n    var items = [];\n    return eachCursor(store, function (cursor) {\n      return items.push(cursor.value);\n    }).then(function () {\n      return items;\n    });\n  });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction entries() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    // Fast path for modern browsers\n    // (although, hopefully we'll get a simpler path some day)\n    if (store.getAll && store.getAllKeys) {\n      return Promise.all([promisifyRequest(store.getAllKeys()), promisifyRequest(store.getAll())]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            keys = _ref2[0],\n            values = _ref2[1];\n\n        return keys.map(function (key, i) {\n          return [key, values[i]];\n        });\n      });\n    }\n\n    var items = [];\n    return customStore('readonly', function (store) {\n      return eachCursor(store, function (cursor) {\n        return items.push([cursor.key, cursor.value]);\n      }).then(function () {\n        return items;\n      });\n    });\n  });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","/**\n * Work around Safari 14 IndexedDB open bug.\n *\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up. https://bugs.webkit.org/show_bug.cgi?id=226547\n * The only solution is to keep nudging it until it's awake.\n */\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    // No point putting other browsers or older versions of Safari through this mess.\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nexport default idbReady;\n","import { createStore, set, get } from \"idb-keyval\";\n\n// update at the same time as the version in cache.js\nconst CACHE_VERSION = \"@VERSION@\";\nconst CACHE_NAME = `zusam-${CACHE_VERSION}`;\n\nconst cache_store = createStore(CACHE_NAME, CACHE_NAME);\nconst cached_routes = [\n  //{\n  //  // Can lead to update issues. It's here for speed optimization (with a low timeout)\n  //  route: new RegExp(\"/api/users/[^/]+/?$\"),\n  //  duration: 1000 * 60 * 1, // 1mn\n  //},\n  //{\n  //  // Can lead to update issues. It's here for speed optimization (with a low timeout)\n  //  route: new RegExp(\"/api/groups/[^/]+/?$\"),\n  //  duration: 1000 * 60 * 2, // 2mn\n  //},\n  //{\n  //  // Can lead to update issues. It's here for speed optimization (with a low timeout)\n  //  route: new RegExp(\"/api/messages/[^/]+/preview/?$\"),\n  //  duration: 1000 * 60 * 5, // 5mn\n  //},\n  //{\n  //  route: new RegExp(\"/api/notifications/[^/]+/?$\"),\n  //  duration: 1000 * 60 * 60 * 24, // 24h\n  //},\n  {\n    route: new RegExp(\"/api/images/crop/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/images/thumbnail/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  //{\n  //  route: new RegExp(\"/api/links/by_url\\?\"),\n  //  duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  //}\n];\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener(\"fetch\", (evt) => {\n  if (evt.request.method == \"GET\") {\n    // cache-update routes: retrieve from cache and update in background\n    if (cached_routes.some(r => evt.request.url.match(r.route))) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n\n      // ...and `waitUntil()` to prevent the worker from being killed until the function is finished.\n      evt.waitUntil(() => {\n        get(evt.request.url, cache_store)\n          .then(r => {\n            if (r && Object.protoype.hasOwnProperty.call(r, \"updatedAt\") && r.updatedAt != null) {\n              const timeout = r.updatedAt + cached_routes.find(r => evt.request.url.match(r.route))[\"duration\"];\n              // update the cache only if the timeout is reached\n              if (timeout < Date.now()) {\n                update(evt.request);\n              }\n            }\n          })\n          .catch(() => update(evt.request));\n      });\n    }\n  }\n});\n\n// Add response to cache and store the lastUsedAt/updatedAt timestamp at the same time\nfunction addToCache(cache, request, response) {\n  return set(\n    request.url,\n    {\n      lastUsedAt: Date.now(),\n      updatedAt: Date.now(),\n    },\n    cache_store\n  ).then(() => cache.put(request, response));\n}\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, toCache) {\n  return fetch(request).then(response => {\n    if (toCache) {\n      // response may be used only once\n      // we need to save clone to put one copy in cache\n      // and serve second one\n      let responseClone = response.clone();\n      caches.open(CACHE_NAME).then(cache => addToCache(cache, request, responseClone));\n    }\n    return response;\n  });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(CACHE_NAME).then(cache => {\n    return cache.match(request).then(matching => {\n      if (matching) {\n        // reset lastUsedAt\n        return set(\n          request.url,\n          {\n            lastUsedAt: Date.now()\n          },\n          cache_store\n        ).then(() => matching);\n      }\n      // if nothing matches, return response from network\n      return fromNetwork(request, true);\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(CACHE_NAME).then(cache => {\n    return fetch(request).then(response => {\n      return addToCache(cache, request, response);\n    });\n  });\n}\n"],"names":["$2e54dcae56d7de31$var$defaultGetStoreFunc","$59b5d8150c90f190$export$2e2bcd8739ae039","intervalId","navigator","userAgentData","test","userAgent","indexedDB","databases","Promise","resolve","tryIdb","finally","setInterval","clearInterval","$2e54dcae56d7de31$export$b327150396135fe7","request","reject","oncomplete","onsuccess","result","onabort","onerror","error","$2e54dcae56d7de31$export$f51a9068ac82ea43","dbName","storeName","dbp","then","open","onupgradeneeded","createObjectStore","txMode","callback","db","transaction","objectStore","$2e54dcae56d7de31$var$defaultGetStore","$2e54dcae56d7de31$export$adaa4cf7ef1b65be","key","value","customStore","arguments","length","undefined","store","put","CACHE_NAME","cache_store","createStore","cached_routes","route","RegExp","duration","addToCache","cache","response","set","url","lastUsedAt","Date","now","updatedAt","update","caches","fetch","self","addEventListener","evt","method","some","r","match","respondWith","matching","toCache","responseClone","clone","fromNetwork","waitUntil","get","Object","protoype","hasOwnProperty","call","find","catch"],"version":3,"file":"service-workers.js.map"}