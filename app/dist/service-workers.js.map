{"mappings":"YAYA,SAASA,EAAiBC,GACxB,OAAO,IAAIC,SAAQ,SAAUC,EAASC,GAEpCH,EAAQI,WAAaJ,EAAQK,UAAY,WACvC,OAAOH,EAAQF,EAAQM,SAIzBN,EAAQO,QAAUP,EAAQQ,QAAU,WAClC,OAAOL,EAAOH,EAAQS,WAK5B,SAASC,EAAYC,EAAQC,GAC3B,IAAIZ,EAAUa,UAAUC,KAAKH,GAE7BX,EAAQe,gBAAkB,WACxB,OAAOf,EAAQM,OAAOU,kBAAkBJ,IAG1C,IAAIK,EAAMlB,EAAiBC,GAC3B,OAAO,SAAUkB,EAAQC,GACvB,OAAOF,EAAIG,MAAK,SAAUC,GACxB,OAAOF,EAASE,EAAGC,YAAYV,EAAWM,GAAQK,YAAYX,QAKpE,IAAIY,EAEJ,SAASC,IAKP,OAJKD,IACHA,EAAsBd,EAAY,eAAgB,WAG7Cc,EAUT,SAASE,EAAIC,GACX,IAAIC,EAAcC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAKJ,IACtF,OAAOG,EAAY,YAAY,SAAUI,GACvC,OAAOjC,EAAiBiC,EAAMC,IAAIN,OAYtC,SAASO,EAAIP,EAAKQ,GAChB,IAAIP,EAAcC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAKJ,IACtF,OAAOG,EAAY,aAAa,SAAUI,GAExC,OADAA,EAAMI,IAAID,EAAOR,GACV5B,EAAiBiC,EAAMV,gBC1ElC,MACMe,EAAc,kBAEdC,EAAcC,EAAYF,EAAYA,GACtCG,EAAgB,CAoBpB,CACEC,MAAO,IAAIC,OAAO,qBAClBC,SAAU,SAEZ,CACEF,MAAO,IAAIC,OAAO,0BAClBC,SAAU,UAqCd,SAASC,EAAWC,EAAO7C,EAAS8C,GAClC,OAAOC,EACL/C,EAAQgD,IACR,CACEC,WAAYC,KAAKC,MACjBC,UAAWF,KAAKC,OAElBb,GACAlB,MAAK,IAAMyB,EAAMT,IAAIpC,EAAS8C,KAyClC,SAASO,EAAOrD,GACd,OAAOsD,OAAOxC,KAAKuB,GAAYjB,MAAKyB,GAC3BU,MAAMvD,GAASoB,MAAK0B,GAClBF,EAAWC,EAAO7C,EAAS8C,OA/ExCU,KAAKC,iBAAiB,SAAUC,IAuDhC,IAAmB1D,EAtDS,OAAtB0D,EAAI1D,QAAQ2D,QAEVnB,EAAcoB,MAAKC,GAAKH,EAAI1D,QAAQgD,IAAIc,MAAMD,EAAEpB,WAGlDiB,EAAIK,aAiDS/D,EAjDa0D,EAAI1D,QAkD3BsD,OAAOxC,KAAKuB,GAAYjB,MAAKyB,GAC3BA,EAAMiB,MAAM9D,GAASoB,MAAK4C,GAC3BA,EAEKjB,EACL/C,EAAQgD,IACR,CACEC,WAAYC,KAAKC,OAEnBb,GACAlB,MAAK,IAAM4C,IA3BrB,SAAqBhE,EAASiE,GAC5B,OAAOV,MAAMvD,GAASoB,MAAK0B,IACzB,GAAImB,EAAS,CAIX,IAAIC,EAAgBpB,EAASqB,QAC7Bb,OAAOxC,KAAKuB,GAAYjB,MAAKyB,GAASD,EAAWC,EAAO7C,EAASkE,KAEnE,OAAOpB,KAqBEsB,CAAYpE,GAAS,SA5D5B0D,EAAIW,WAAU,KACZpC,EAAIyB,EAAI1D,QAAQgD,IAAKV,GAClBlB,MAAKyC,IACJ,GAAIA,GAAKS,OAAOC,SAASC,eAAeC,KAAKZ,EAAG,cAA+B,MAAfA,EAAET,UAAmB,CACnES,EAAET,UAAYZ,EAAckC,MAAKb,GAAKH,EAAI1D,QAAQgD,IAAIc,MAAMD,EAAEpB,SAAhD,SAEhBS,KAAKC,OACjBE,EAAOK,EAAI1D,aAIhB2E,OAAM,IAAMtB,EAAOK,EAAI1D,kB","sources":["node_modules/idb-keyval/dist/compat.js","src/service-workers.js"],"sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction promisifyRequest(request) {\n  return new Promise(function (resolve, reject) {\n    // @ts-ignore - file size hacks\n    request.oncomplete = request.onsuccess = function () {\n      return resolve(request.result);\n    }; // @ts-ignore - file size hacks\n\n\n    request.onabort = request.onerror = function () {\n      return reject(request.error);\n    };\n  });\n}\n\nfunction createStore(dbName, storeName) {\n  var request = indexedDB.open(dbName);\n\n  request.onupgradeneeded = function () {\n    return request.result.createObjectStore(storeName);\n  };\n\n  var dbp = promisifyRequest(request);\n  return function (txMode, callback) {\n    return dbp.then(function (db) {\n      return callback(db.transaction(storeName, txMode).objectStore(storeName));\n    });\n  };\n}\n\nvar defaultGetStoreFunc;\n\nfunction defaultGetStore() {\n  if (!defaultGetStoreFunc) {\n    defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n  }\n\n  return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction get(key) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    return promisifyRequest(store.get(key));\n  });\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction set(key, value) {\n  var customStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.put(value, key);\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction setMany(entries) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    entries.forEach(function (entry) {\n      return store.put(entry[1], entry[0]);\n    });\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction getMany(keys) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    return Promise.all(keys.map(function (key) {\n      return promisifyRequest(store.get(key));\n    }));\n  });\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction update(key, updater) {\n  var customStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    return (// Need to create the promise manually.\n      // If I try to chain promises, the transaction closes in browsers\n      // that use a promise polyfill (IE10/11).\n      new Promise(function (resolve, reject) {\n        store.get(key).onsuccess = function () {\n          try {\n            store.put(updater(this.result), key);\n            resolve(promisifyRequest(store.transaction));\n          } catch (err) {\n            reject(err);\n          }\n        };\n      })\n    );\n  });\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction del(key) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.delete(key);\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction delMany(keys) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    keys.forEach(function (key) {\n      return store.delete(key);\n    });\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction clear() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.clear();\n    return promisifyRequest(store.transaction);\n  });\n}\n\nfunction eachCursor(store, callback) {\n  store.openCursor().onsuccess = function () {\n    if (!this.result) return;\n    callback(this.result);\n    this.result.continue();\n  };\n\n  return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction keys() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    // Fast path for modern browsers\n    if (store.getAllKeys) {\n      return promisifyRequest(store.getAllKeys());\n    }\n\n    var items = [];\n    return eachCursor(store, function (cursor) {\n      return items.push(cursor.key);\n    }).then(function () {\n      return items;\n    });\n  });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction values() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    // Fast path for modern browsers\n    if (store.getAll) {\n      return promisifyRequest(store.getAll());\n    }\n\n    var items = [];\n    return eachCursor(store, function (cursor) {\n      return items.push(cursor.value);\n    }).then(function () {\n      return items;\n    });\n  });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction entries() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    // Fast path for modern browsers\n    // (although, hopefully we'll get a simpler path some day)\n    if (store.getAll && store.getAllKeys) {\n      return Promise.all([promisifyRequest(store.getAllKeys()), promisifyRequest(store.getAll())]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            keys = _ref2[0],\n            values = _ref2[1];\n\n        return keys.map(function (key, i) {\n          return [key, values[i]];\n        });\n      });\n    }\n\n    var items = [];\n    return customStore('readonly', function (store) {\n      return eachCursor(store, function (cursor) {\n        return items.push([cursor.key, cursor.value]);\n      }).then(function () {\n        return items;\n      });\n    });\n  });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","import { createStore, set, get } from \"idb-keyval\";\n\n// update at the same time as the version in cache.js\nconst CACHE_VERSION = \"@VERSION@\";\nconst CACHE_NAME = `zusam-${CACHE_VERSION}`;\n\nconst cache_store = createStore(CACHE_NAME, CACHE_NAME);\nconst cached_routes = [\n  //{\n  //  // Can lead to update issues. It's here for speed optimization (with a low timeout)\n  //  route: new RegExp(\"/api/users/[^/]+/?$\"),\n  //  duration: 1000 * 60 * 1, // 1mn\n  //},\n  //{\n  //  // Can lead to update issues. It's here for speed optimization (with a low timeout)\n  //  route: new RegExp(\"/api/groups/[^/]+/?$\"),\n  //  duration: 1000 * 60 * 2, // 2mn\n  //},\n  //{\n  //  // Can lead to update issues. It's here for speed optimization (with a low timeout)\n  //  route: new RegExp(\"/api/messages/[^/]+/preview/?$\"),\n  //  duration: 1000 * 60 * 5, // 5mn\n  //},\n  //{\n  //  route: new RegExp(\"/api/notifications/[^/]+/?$\"),\n  //  duration: 1000 * 60 * 60 * 24, // 24h\n  //},\n  {\n    route: new RegExp(\"/api/images/crop/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/images/thumbnail/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  //{\n  //  route: new RegExp(\"/api/links/by_url\\?\"),\n  //  duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  //}\n];\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener(\"fetch\", (evt) => {\n  if (evt.request.method == \"GET\") {\n    // cache-update routes: retrieve from cache and update in background\n    if (cached_routes.some(r => evt.request.url.match(r.route))) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n\n      // ...and `waitUntil()` to prevent the worker from being killed until the function is finished.\n      evt.waitUntil(() => {\n        get(evt.request.url, cache_store)\n          .then(r => {\n            if (r && Object.protoype.hasOwnProperty.call(r, \"updatedAt\") && r.updatedAt != null) {\n              const timeout = r.updatedAt + cached_routes.find(r => evt.request.url.match(r.route))[\"duration\"];\n              // update the cache only if the timeout is reached\n              if (timeout < Date.now()) {\n                update(evt.request);\n              }\n            }\n          })\n          .catch(() => update(evt.request));\n      });\n    }\n  }\n});\n\n// Add response to cache and store the lastUsedAt/updatedAt timestamp at the same time\nfunction addToCache(cache, request, response) {\n  return set(\n    request.url,\n    {\n      lastUsedAt: Date.now(),\n      updatedAt: Date.now(),\n    },\n    cache_store\n  ).then(() => cache.put(request, response));\n}\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, toCache) {\n  return fetch(request).then(response => {\n    if (toCache) {\n      // response may be used only once\n      // we need to save clone to put one copy in cache\n      // and serve second one\n      let responseClone = response.clone();\n      caches.open(CACHE_NAME).then(cache => addToCache(cache, request, responseClone));\n    }\n    return response;\n  });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(CACHE_NAME).then(cache => {\n    return cache.match(request).then(matching => {\n      if (matching) {\n        // reset lastUsedAt\n        return set(\n          request.url,\n          {\n            lastUsedAt: Date.now()\n          },\n          cache_store\n        ).then(() => matching);\n      }\n      // if nothing matches, return response from network\n      return fromNetwork(request, true);\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(CACHE_NAME).then(cache => {\n    return fetch(request).then(response => {\n      return addToCache(cache, request, response);\n    });\n  });\n}\n"],"names":["$2e54dcae56d7de31$export$b327150396135fe7","request","Promise","resolve","reject","oncomplete","onsuccess","result","onabort","onerror","error","$2e54dcae56d7de31$export$f51a9068ac82ea43","dbName","storeName","indexedDB","open","onupgradeneeded","createObjectStore","dbp","txMode","callback","then","db","transaction","objectStore","$2e54dcae56d7de31$var$defaultGetStoreFunc","$2e54dcae56d7de31$var$defaultGetStore","$2e54dcae56d7de31$export$3988ae62b71be9a3","key","customStore","arguments","length","undefined","store","get","$2e54dcae56d7de31$export$adaa4cf7ef1b65be","value","put","CACHE_NAME","cache_store","createStore","cached_routes","route","RegExp","duration","addToCache","cache","response","set","url","lastUsedAt","Date","now","updatedAt","update","caches","fetch","self","addEventListener","evt","method","some","r","match","respondWith","matching","toCache","responseClone","clone","fromNetwork","waitUntil","Object","protoype","hasOwnProperty","call","find","catch"],"version":3,"file":"service-workers.js.map"}