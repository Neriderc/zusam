{"mappings":"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","sources":["node_modules/idb-keyval/dist/compat.js","node_modules/safari-14-idb-fix/dist/index.js","src/service-workers.js"],"sourcesContent":["import safariFix from 'safari-14-idb-fix';\n\nfunction promisifyRequest(request) {\n  return new Promise(function (resolve, reject) {\n    // @ts-ignore - file size hacks\n    request.oncomplete = request.onsuccess = function () {\n      return resolve(request.result);\n    }; // @ts-ignore - file size hacks\n\n\n    request.onabort = request.onerror = function () {\n      return reject(request.error);\n    };\n  });\n}\n\nfunction createStore(dbName, storeName) {\n  var dbp = safariFix().then(function () {\n    var request = indexedDB.open(dbName);\n\n    request.onupgradeneeded = function () {\n      return request.result.createObjectStore(storeName);\n    };\n\n    return promisifyRequest(request);\n  });\n  return function (txMode, callback) {\n    return dbp.then(function (db) {\n      return callback(db.transaction(storeName, txMode).objectStore(storeName));\n    });\n  };\n}\n\nvar defaultGetStoreFunc;\n\nfunction defaultGetStore() {\n  if (!defaultGetStoreFunc) {\n    defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n  }\n\n  return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction get(key) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    return promisifyRequest(store.get(key));\n  });\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction set(key, value) {\n  var customStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.put(value, key);\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction setMany(entries) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    entries.forEach(function (entry) {\n      return store.put(entry[1], entry[0]);\n    });\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction getMany(keys) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readonly', function (store) {\n    return Promise.all(keys.map(function (key) {\n      return promisifyRequest(store.get(key));\n    }));\n  });\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction update(key, updater) {\n  var customStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    return (// Need to create the promise manually.\n      // If I try to chain promises, the transaction closes in browsers\n      // that use a promise polyfill (IE10/11).\n      new Promise(function (resolve, reject) {\n        store.get(key).onsuccess = function () {\n          try {\n            store.put(updater(this.result), key);\n            resolve(promisifyRequest(store.transaction));\n          } catch (err) {\n            reject(err);\n          }\n        };\n      })\n    );\n  });\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction del(key) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.delete(key);\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction delMany(keys) {\n  var customStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    keys.forEach(function (key) {\n      return store.delete(key);\n    });\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction clear() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  return customStore('readwrite', function (store) {\n    store.clear();\n    return promisifyRequest(store.transaction);\n  });\n}\n\nfunction eachCursor(customStore, callback) {\n  return customStore('readonly', function (store) {\n    // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\n    // And openKeyCursor isn't supported by Safari.\n    store.openCursor().onsuccess = function () {\n      if (!this.result) return;\n      callback(this.result);\n      this.result.continue();\n    };\n\n    return promisifyRequest(store.transaction);\n  });\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction keys() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  var items = [];\n  return eachCursor(customStore, function (cursor) {\n    return items.push(cursor.key);\n  }).then(function () {\n    return items;\n  });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction values() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  var items = [];\n  return eachCursor(customStore, function (cursor) {\n    return items.push(cursor.value);\n  }).then(function () {\n    return items;\n  });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\n\n\nfunction entries() {\n  var customStore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetStore();\n  var items = [];\n  return eachCursor(customStore, function (cursor) {\n    return items.push([cursor.key, cursor.value]);\n  }).then(function () {\n    return items;\n  });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","/**\n * Work around Safari 14 IndexedDB open bug.\n *\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up. https://bugs.webkit.org/show_bug.cgi?id=226547\n * The only solution is to keep nudging it until it's awake.\n */\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    // No point putting other browsers or older versions of Safari through this mess.\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nexport default idbReady;\n","import { createStore, set, get } from \"idb-keyval\";\n\n// update at the same time as the version in cache.js\nconst CACHE_VERSION = \"0.5\";\nconst CACHE_NAME = `zusam-${CACHE_VERSION}`;\n\nconst cache_store = createStore(CACHE_NAME, CACHE_NAME);\nconst cached_routes = [\n  {\n    route: new RegExp(\"/api/users/[^/]+/?$\"),\n    duration: 1000 * 60 * 1, // 1mn\n  },\n  {\n    route: new RegExp(\"/api/groups/[^/]+/?$\"),\n    duration: 1000 * 60 * 1, // 1mn\n  },\n  {\n    route: new RegExp(\"/api/notifications/[^/]+/?$\"),\n    duration: 1000 * 60 * 60 * 24, // 24h\n  },\n  {\n    route: new RegExp(\"/api/images/crop/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/images/thumbnail/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/links/by_url\\?\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  }\n];\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener(\"fetch\", (evt) => {\n  if (evt.request.method == \"GET\") {\n    // cache-update routes: retrieve from cache and update in background\n    if (cached_routes.some(r => evt.request.url.match(r.route))) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n\n      // ...and `waitUntil()` to prevent the worker from being killed until the function is finished.\n      evt.waitUntil(() => {\n        get(evt.request.url, cache_store)\n          .then(r => {\n            if (r && Object.protoype.hasOwnProperty.call(r, \"lastUsed\") && r.lastUsed != null) {\n              const timeout = r.lastUsed + cached_routes.find(r => evt.request.url.match(r.route))[\"duration\"];\n              // update the cache only if the timeout is reached\n              if (timeout < Date.now()) {\n                update(evt.request);\n              }\n            }\n          })\n          .catch(() => update(evt.request));\n      });\n    }\n  }\n});\n\n// Add response to cache and store the lastUsed timestamp at the same time\nfunction addToCache(cache, request, response) {\n  return set(\n    request.url,\n    {\n      lastUsed: Date.now()\n    },\n    cache_store\n  ).then(() => cache.put(request, response));\n}\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, toCache) {\n  return fetch(request).then(response => {\n    if (toCache) {\n      // response may be used only once\n      // we need to save clone to put one copy in cache\n      // and serve second one\n      let responseClone = response.clone();\n      caches.open(CACHE_NAME).then(cache => addToCache(cache, request, responseClone));\n    }\n    return response;\n  });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(CACHE_NAME).then(cache => {\n    return cache.match(request).then(matching => {\n      if (matching) {\n        // reset lastUsed\n        return set(\n          request.url,\n          {\n            lastUsed: Date.now()\n          },\n          cache_store\n        ).then(() => matching);\n      }\n        // if nothing matches, return response from network\n        return fromNetwork(request, true);\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(CACHE_NAME).then(cache => {\n    return fetch(request).then(response => {\n      return addToCache(cache, request, response);\n    });\n  });\n}\n"],"names":["$2e54dcae56d7de31$var$defaultGetStoreFunc","$59b5d8150c90f190$export$2e2bcd8739ae039","intervalId","navigator","userAgentData","test","userAgent","indexedDB","databases","Promise","resolve","tryIdb","finally","setInterval","clearInterval","$2e54dcae56d7de31$export$b327150396135fe7","request","reject","oncomplete","onsuccess","result","onabort","onerror","error","$2e54dcae56d7de31$export$f51a9068ac82ea43","dbName","storeName","dbp","then","open","onupgradeneeded","createObjectStore","txMode","callback","db","transaction","objectStore","$2e54dcae56d7de31$var$defaultGetStore","$2e54dcae56d7de31$export$adaa4cf7ef1b65be","key","value","customStore","arguments","length","undefined","store","put","CACHE_NAME","cache_store","createStore","cached_routes","route","RegExp","duration","addToCache","cache","response","set","url","lastUsed","Date","now","update","caches","fetch","self","addEventListener","evt","method","some","r","match","respondWith","matching","toCache","responseClone","clone","fromNetwork","waitUntil","get","Object","protoype","hasOwnProperty","call","find","catch"],"version":3,"file":"service-workers.js.map"}