{"version":3,"sources":["../node_modules/idb-keyval/dist/idb-keyval.mjs","service-workers.js"],"names":["Store","constructor","dbName","storeName","_dbp","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","createObjectStore","_withIDBStore","type","callback","then","db","transaction","oncomplete","onabort","objectStore","store","getDefaultStore","get","key","req","set","value","put","del","delete","clear","keys","openKeyCursor","openCursor","call","push","continue","CACHE_VERSION","cache_store","cached_routes","route","RegExp","duration","addToCache","cache","request","response","url","lastUsed","Date","now","fromNetwork","toCache","fetch","responseClone","clone","caches","param","CACHE","fromCache","match","matching","update","self","addEventListener","evt","method","some","r","respondWith","waitUntil","Object","protoype","hasOwnProperty","find","catch"],"mappings":"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","file":"service-workers.js","sourceRoot":"../src","sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","import { Store, set, get } from \"idb-keyval\";\n\n// update at the same time as the version in cache.js\nconst CACHE_VERSION = \"0.4\";\n\nconst cache_store = new Store(`zusam-${CACHE_VERSION}`, `zusam-simplecache-${CACHE_VERSION}`);\nconst cached_routes = [\n  {\n    route: new RegExp(\"/api/users/[^/]+/?$\"),\n    duration: 1000 * 60 * 60 * 24, // 24h\n  },\n  {\n    route: new RegExp(\"/api/images/crop/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/images/thumbnail/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/links/by_url\\?\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  }\n];\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener(\"fetch\", (evt) => {\n  if (evt.request.method == \"GET\") {\n    // cache-update routes: retrieve from cache and update in background\n    if (cached_routes.some(r => evt.request.url.match(r.route))) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n\n      // ...and `waitUntil()` to prevent the worker from being killed until the function is finished.\n      evt.waitUntil(() => {\n        get(evt.request.url, cache_store)\n          .then(r => {\n            if (r && Object.protoype.hasOwnProperty.call(r, \"lastUsed\") && r.lastUsed != null) {\n              const timeout = r.lastUsed + cached_routes.find(r => evt.request.url.match(r.route))[\"duration\"];\n              // update the cache only if the timeout is reached\n              if (timeout < Date.now()) {\n                update(evt.request);\n              }\n            }\n          })\n          .catch(() => update(evt.request));\n      });\n    }\n  }\n});\n\n// Add response to cache and store the lastUsed timestamp at the same time\nfunction addToCache(cache, request, response) {\n  return set(\n    request.url,\n    {\n      lastUsed: Date.now()\n    },\n    cache_store\n  ).then(() => cache.put(request, response));\n}\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, toCache) {\n  return fetch(request).then(response => {\n    if (toCache) {\n      // response may be used only once\n      // we need to save clone to put one copy in cache\n      // and serve second one\n      let responseClone = response.clone();\n      caches.open(param.CACHE).then(cache => addToCache(cache, request, responseClone));\n    }\n    return response;\n  });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(param.CACHE).then(cache => {\n    return cache.match(request).then(matching => {\n      if (matching) {\n        // reset lastUsed\n        return set(\n          request.url,\n          {\n            lastUsed: Date.now()\n          },\n          cache_store\n        ).then(() => matching);\n      }\n        // if nothing matches, return response from network\n        return fromNetwork(request, true);\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(param.CACHE).then(cache => {\n    return fetch(request).then(response => {\n      return addToCache(cache, request, response);\n    });\n  });\n}\n"]}